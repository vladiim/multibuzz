# Identity Resolution & Session Tracking

Version: 1.0.0
Last Updated: 2025-11-28

This document defines Multibuzz's identity model and session tracking system. These are the foundational concepts that enable multi-touch attribution across devices, channels, and time.

---

## The Problem We're Solving

A single person interacts with a business across multiple touchpoints:

| Touchpoint | Identifier | Context |
|------------|------------|---------|
| First website visit (desktop) | visitor_id: `abc` | utm_source=google |
| Second visit (mobile) | visitor_id: `def` | utm_source=facebook |
| Signs up for newsletter | email: `jane@example.com` | - |
| Creates account | user_id: `usr_123` | - |
| Returns on desktop | visitor_id: `abc` | direct |
| Purchases in-store | loyalty_id: `L789` | sales associate |
| Downloads mobile app | device_id: `app_456` | - |

**Without identity resolution:** Each touchpoint is isolated. Attribution is impossible.

**With identity resolution:** All touchpoints resolve to one Person. Full journey visible.

---

## Core Concepts

### Person

The actual human being. Never directly stored - instead, resolved from linked identifiers.

A Person is the union of all Visitors and Users that have been linked together.

### Visitor

An anonymous identifier representing a browser/device.

| Property | Description |
|----------|-------------|
| `visitor_id` | 64-char hex string, generated by SDK |
| Scope | Single browser/device |
| Lifetime | 2 years (cookie expiry) |
| Creation | Automatic on first visit |

A Person may have **many** Visitors (multiple devices/browsers).

### User

A known, identified individual in the customer's system.

| Property | Description |
|----------|-------------|
| `user_id` | Customer-provided identifier |
| Scope | Cross-device, cross-channel |
| Lifetime | Permanent |
| Creation | When customer calls `identify` or `alias` |

A Person has **one** User identity (though the user_id format is up to the customer).

### Session

A single visit/browsing session with acquisition context.

| Property | Description |
|----------|-------------|
| `session_id` | 64-char hex string, generated by SDK |
| Belongs to | One Visitor |
| Lifetime | 30 minutes of inactivity |
| Key data | UTMs, referrer, channel, landing page |

Sessions are the **touchpoints** used in attribution.

---

## Identity Resolution

### The Link: Visitor → User

When a customer identifies a user (signup, login, etc.), they create a link:

```
Visitor (abc) ──────→ User (usr_123)
```

This link is **bidirectional in time**:

- **Backward:** All past sessions from Visitor `abc` are now attributed to User `usr_123`
- **Forward:** All future sessions from Visitor `abc` are attributed to User `usr_123`

### Multiple Visitors, One User

When a user logs in on a new device:

```
Visitor (abc) ─────┐
                   ├──→ User (usr_123)
Visitor (def) ─────┘
```

Now both visitors' sessions contribute to attribution for this user.

### Resolution at Query Time

When calculating attribution for a conversion:

1. Start with the User (or Visitor if anonymous)
2. Find ALL Visitors linked to that User
3. Find ALL Sessions from those Visitors
4. Apply attribution model across all sessions

```sql
-- Pseudocode: Find all sessions for a user's attribution
SELECT sessions.*
FROM sessions
JOIN visitors ON sessions.visitor_id = visitors.id
WHERE visitors.user_id = :user_id
   OR visitors.id = :converting_visitor_id
ORDER BY sessions.started_at
```

---

## Cross-Channel Identity

### Web to In-Store

Customer purchases in-store, provides email:

1. POS system looks up user by email
2. Creates conversion with `user_id`
3. Attribution includes all web sessions from linked visitors

```
Web Visit (visitor: abc) ────→ User (usr_123) ←──── In-Store Purchase
     utm_source=google              ↑
                                    │
                              (linked via email)
```

### Web to Mobile App

User downloads app, logs in:

1. App generates new visitor_id (or device_id)
2. User logs in → `alias` called
3. App sessions linked to same user as web sessions

### Offline Import

Customer imports CRM data:

1. Provide `user_id` + conversion data
2. If user has linked visitors → full attribution
3. If no linked visitors → conversion tracked but limited attribution

---

## API Operations

### 1. Create Session

**When:** Every new browsing session (detected by SDK middleware)

**Purpose:** Record that a visitor landed, with full acquisition context

**Endpoint:** `POST /api/v1/sessions`

```json
{
  "session": {
    "visitor_id": "abc123...",
    "session_id": "xyz789...",
    "url": "https://example.com/landing?utm_source=google&utm_medium=cpc",
    "referrer": "https://google.com/search",
    "started_at": "2025-11-28T12:00:00Z"
  }
}
```

**What happens:**
- Visitor record created (if first visit)
- Session record created with:
  - UTM parameters extracted from URL
  - Referrer host/path extracted
  - Channel derived (paid_search, organic, email, etc.)
  - Landing page stored

**Response:** `202 Accepted` (processing is async)

### 2. Identify User

**When:** Customer knows who the user is (signup, login, profile update)

**Purpose:** Associate traits with a user identity

**Endpoint:** `POST /api/v1/identify`

```json
{
  "user_id": "usr_123",
  "visitor_id": "abc123...",
  "traits": {
    "email": "jane@example.com",
    "name": "Jane Doe",
    "plan": "pro"
  }
}
```

**What happens:**
- User record created/updated with traits
- If `visitor_id` provided, creates the Visitor → User link

### 3. Alias (Link Visitor to User)

**When:** Visitor becomes known (signup complete, login)

**Purpose:** Explicitly link a visitor to a user for attribution

**Endpoint:** `POST /api/v1/alias`

```json
{
  "visitor_id": "abc123...",
  "user_id": "usr_123"
}
```

**What happens:**
- Creates Visitor → User link
- All past sessions from this visitor now attributed to user
- All future sessions from this visitor attributed to user

### 4. Track Event

**When:** User performs a trackable action

**Purpose:** Record an event for analytics/attribution

**Endpoint:** `POST /api/v1/events`

```json
{
  "events": [{
    "event_type": "add_to_cart",
    "visitor_id": "abc123...",
    "user_id": "usr_123",
    "properties": { "product_id": "SKU-001", "price": 49.99 }
  }]
}
```

### 5. Track Conversion

**When:** User converts (purchase, signup, etc.)

**Purpose:** Record conversion and calculate attribution

**Endpoint:** `POST /api/v1/conversions`

```json
{
  "conversion": {
    "visitor_id": "abc123...",
    "conversion_type": "purchase",
    "revenue": 99.99
  }
}
```

**What happens:**
1. Find the Visitor
2. Find linked User (if any)
3. Find ALL Visitors linked to that User
4. Find ALL Sessions within lookback window
5. Apply attribution models
6. Return attribution breakdown

---

## Data Model

### Visitors

| Field | Type | Description |
|-------|------|-------------|
| `id` | bigint | Internal primary key |
| `account_id` | bigint | Customer account (multi-tenancy) |
| `visitor_id` | string(64) | SDK-generated identifier |
| `user_id` | bigint (nullable) | Link to User (when identified) |
| `first_seen_at` | timestamp | First session start |
| `last_seen_at` | timestamp | Most recent activity |
| `traits` | jsonb | Visitor-level properties |

**Unique constraint:** `(account_id, visitor_id)`

### Users

| Field | Type | Description |
|-------|------|-------------|
| `id` | bigint | Internal primary key |
| `account_id` | bigint | Customer account |
| `external_id` | string | Customer's user identifier |
| `traits` | jsonb | User properties (email, name, etc.) |
| `first_identified_at` | timestamp | When first identified |
| `last_identified_at` | timestamp | Most recent identify call |

**Unique constraint:** `(account_id, external_id)`

### Sessions

| Field | Type | Description |
|-------|------|-------------|
| `id` | bigint | Internal primary key |
| `account_id` | bigint | Customer account |
| `visitor_id` | bigint | FK to Visitors |
| `session_id` | string(64) | SDK-generated identifier |
| `started_at` | timestamp | Session start time |
| `ended_at` | timestamp (nullable) | Session end (inactivity timeout) |
| `initial_utm` | jsonb | UTM params at session start |
| `initial_referrer` | string | Referrer URL at session start |
| `channel` | string | Derived channel (paid_search, etc.) |
| `landing_host` | string | Landing page domain |
| `landing_path` | string | Landing page path |

**Key insight:** Sessions belong to Visitors, not Users. The Visitor → User link resolves sessions to users at query time.

### Conversions

| Field | Type | Description |
|-------|------|-------------|
| `id` | bigint | Internal primary key |
| `account_id` | bigint | Customer account |
| `visitor_id` | bigint (nullable) | Converting visitor |
| `user_id` | bigint (nullable) | Converting user |
| `conversion_type` | string | e.g., "purchase", "signup" |
| `revenue` | decimal | Revenue amount |
| `attributed_at` | timestamp | When conversion occurred |

**Constraint:** Must have at least one of `visitor_id` or `user_id`

---

## Attribution Query Flow

When a conversion is recorded:

```
1. IDENTIFY THE PERSON
   ├─ If user_id provided → Find User
   │    └─ Find all Visitors linked to User
   └─ If only visitor_id → Use that Visitor
        └─ Check if Visitor has linked User → expand to all their Visitors

2. GATHER SESSIONS
   └─ For each Visitor in the Person's set:
        └─ Find Sessions within lookback window (e.g., 30 days)

3. APPLY ATTRIBUTION
   └─ For each attribution model (first_touch, last_touch, linear, etc.):
        └─ Calculate credit distribution across sessions

4. RETURN RESULTS
   └─ Conversion record + attribution breakdown by model
```

---

## SDK Responsibilities

### What the SDK Does

1. **Generate visitor_id** - On first visit, create and store in cookie
2. **Generate session_id** - On new session, create and store in cookie
3. **Detect new sessions** - No cookie, or 30+ min since last activity
4. **POST /sessions** - Async, non-blocking, on every new session
5. **Provide helpers** - `mbuzz_visitor_id`, `mbuzz_session_id` for app code
6. **Include context** - URL, referrer with every API call

### What the SDK Does NOT Do

1. **Identity resolution** - API handles linking
2. **Attribution calculation** - API handles this
3. **UTM parsing** - API extracts from URL
4. **Channel determination** - API derives from UTM + referrer

The SDK captures and transmits. The API processes and stores.

---

## Timing Considerations

### Session Creation: Fire and Forget

Session POSTs must be:
- **Asynchronous** - Don't block page render
- **Non-critical** - Failures logged but swallowed
- **Idempotent** - Safe to retry

### Identity Operations: Can Be Synchronous

Identify/Alias calls typically happen on:
- Signup (user is waiting anyway)
- Login (user is waiting anyway)
- Profile update (user is waiting anyway)

These can be synchronous if needed for immediate response.

### Conversions: Usually Synchronous

Conversion calls often need the attribution response:
- Display "Thanks for your order from [channel]"
- Store attribution in CRM
- Trigger channel-specific follow-ups

---

## Privacy Considerations

### What We Store

- Visitor IDs (anonymous, no PII)
- Session context (UTMs, referrer, landing page)
- IP addresses (anonymized - last octet masked)
- User-Agent strings
- User traits (as provided by customer)

### What We Don't Store

- Cookies from other sites
- Browsing history beyond our customer's site
- Personal data unless customer provides it

### Data Isolation

All data is strictly scoped to `account_id`. No cross-account queries possible.

---

## Example Scenarios

### Scenario 1: Simple Web Conversion

```
Day 1: Jane visits from Google Ads
       → Session created: visitor=abc, channel=paid_search

Day 3: Jane returns directly, purchases
       → Conversion created: visitor=abc
       → Attribution: 100% to paid_search session
```

### Scenario 2: Multi-Touch, Single Device

```
Day 1: Jane visits from Google Ads
       → Session: visitor=abc, channel=paid_search

Day 5: Jane visits from email campaign
       → Session: visitor=abc, channel=email

Day 7: Jane returns directly, purchases
       → Conversion: visitor=abc
       → Attribution (linear): 33% paid_search, 33% email, 33% direct
```

### Scenario 3: Multi-Device with Identification

```
Day 1: Jane visits on desktop from Google Ads
       → Session: visitor=abc, channel=paid_search

Day 3: Jane visits on mobile from Facebook
       → Session: visitor=def, channel=paid_social

Day 5: Jane signs up on mobile
       → Alias: visitor=def → user=usr_123

Day 6: Jane logs in on desktop
       → Alias: visitor=abc → user=usr_123
       → Now both visitors linked to same user

Day 7: Jane purchases on desktop
       → Conversion: user=usr_123
       → Find all visitors: abc, def
       → Find all sessions: Google (abc), Facebook (def), direct (abc)
       → Attribution spans all devices
```

### Scenario 4: In-Store + Web

```
Day 1: Jane visits website from Google Ads
       → Session: visitor=abc, channel=paid_search

Day 3: Jane signs up (provides email)
       → Alias: visitor=abc → user=usr_123
       → Identify: user=usr_123, email=jane@example.com

Day 10: Jane purchases in-store (provides email)
        → POS looks up user by email → usr_123
        → Conversion: user=usr_123
        → Attribution includes web session from Day 1
```

---

## Related Documentation

- [Event Properties](../docs/architecture/event_properties.md) - How UTMs and context are stored
- [Attribution Models](attribution_dsl_design.md) - How credit is distributed
- [SDK Specification](sdk_specification.md) - SDK implementation guide
